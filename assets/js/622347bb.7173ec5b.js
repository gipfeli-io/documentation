"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[1408],{153:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>d});var a=n(7462),i=(n(7294),n(3905));n(1839);const o={id:"frontend-deployment",sidebar_position:2,title:"Frontend deployment"},r=void 0,s={unversionedId:"infrastructure/frontend-deployment",id:"infrastructure/frontend-deployment",title:"Frontend deployment",description:"Our frontend is built with React using Create React App as a",source:"@site/docs/infrastructure/frontend-deployment.md",sourceDirName:"infrastructure",slug:"/infrastructure/frontend-deployment",permalink:"/docs/infrastructure/frontend-deployment",draft:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{id:"frontend-deployment",sidebar_position:2,title:"Frontend deployment"},sidebar:"tutorialSidebar",previous:{title:"Basics",permalink:"/docs/infrastructure/basics"},next:{title:"Backend deployment",permalink:"/docs/infrastructure/backend-deployment"}},l={},d=[{value:"Deployment steps",id:"deployment-steps",level:2}],p={toc:d};function u(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Our frontend is built with ",(0,i.kt)("a",{parentName:"p",href:"https://reactjs.org/"},"React")," using ",(0,i.kt)("a",{parentName:"p",href:"https://create-react-app.dev/"},"Create React App")," as a\nskeleton builder. Currently, the build output is served via a lightweight ",(0,i.kt)("a",{parentName:"p",href:"https://www.nginx.com/"},"Nginx")," webserver."),(0,i.kt)("admonition",{title:"Why we're using Nginx to serve a static website",type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"Given that a React app is built and only consists of static files (Javascript, CSS, HTML, etc.), there are several ways\nhow these files can be served. Using Nginx is the most straightforward approach since its a basic webserver that serves\nfiles and it comes with all amenities such as GZIP compression, routing and so on."),(0,i.kt)("p",{parentName:"admonition"},"However, it could become more cost-efficient to drop Cloud Run and serve the files from a simple Storage Bucket. That\nwould require a Load Balancer, though, and at the moment the costs of adding a Load Balancer are far higher than using\nCloud Run.")),(0,i.kt)("h2",{id:"deployment-steps"},"Deployment steps"),(0,i.kt)("p",null,"Deployment always happens when a push is sent to main or stage. This triggers\nthe ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/gipfeli-io/gipfeli-frontend/blob/main/.github/workflows/ci.yml"},"GitHub Action")," that\nperforms the following steps:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Run all the the steps in the ",(0,i.kt)("inlineCode",{parentName:"li"},"test-and-build")," job, consisting of",(0,i.kt)("ol",{parentName:"li"},(0,i.kt)("li",{parentName:"ol"},"Run tests"),(0,i.kt)("li",{parentName:"ol"},"Set up environment variables: Because our frontend is statically built, all environment variables need to be\ninjected at buildtime, i.e. in this action's context. As such, they are added to ",(0,i.kt)("inlineCode",{parentName:"li"},"$GITHUB_ENV")," which makes them\navailable as normal environment variables to the build context. Since they are different for staging and main,\nthey can be conditionally defined, and they may also use GitHub secrets."),(0,i.kt)("li",{parentName:"ol"},"Build the container assigning it a unique name (",(0,i.kt)("inlineCode",{parentName:"li"},"gcr.io/{project_id}/{app_name}-{environment}:{commit_sha}"),") and\nproviding the correct build args"),(0,i.kt)("li",{parentName:"ol"},"If we are pushing to either ",(0,i.kt)("inlineCode",{parentName:"li"},"stage")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"main"),":",(0,i.kt)("ol",{parentName:"li"},(0,i.kt)("li",{parentName:"ol"},"establish connection to our Google Cloud account using the\nofficial ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/google-github-actions/auth"},"google-github-actions/auth")," step."),(0,i.kt)("li",{parentName:"ol"},"We can now use ",(0,i.kt)("inlineCode",{parentName:"li"},"gcloud")," tools. First, we configure the container registry."),(0,i.kt)("li",{parentName:"ol"},"We then push the image to the Google Cloud Container Registry"))))),(0,i.kt)("li",{parentName:"ol"},"Depending on whether we push to ",(0,i.kt)("inlineCode",{parentName:"li"},"stage")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"main"),", we run either the ",(0,i.kt)("inlineCode",{parentName:"li"},"deploy-stage")," or the ",(0,i.kt)("inlineCode",{parentName:"li"},"deploy-main")," job. They do\nthe same but use different endpoints to deploy the correct environment. This takes the following steps:",(0,i.kt)("ol",{parentName:"li"},(0,i.kt)("li",{parentName:"ol"},"Authenticate with Google Cloud again"),(0,i.kt)("li",{parentName:"ol"},"Deploy the previously pushed image using ",(0,i.kt)("inlineCode",{parentName:"li"},"gcloud run deploy")))),(0,i.kt)("li",{parentName:"ol"},"After this, the deployment starts, boots up our new image as a new CloudRun pod, performs healthchecks and gracefully\nreplaces the previous running pod with our new pod, redirecting all traffic to this pod.")),(0,i.kt)("admonition",{title:"SonarCloud",type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"Because we do not use coverage analysis in the frontend as we do in the backend, we can use SonarCloud's automatic scan.\nThis is the default for any repository that is configured within SonarCloud and executes automatically on each action\nrun. It will also automagically create a comment on every pull request with a short summary.")))}u.isMDXComponent=!0}}]);